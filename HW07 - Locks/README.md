# Домашнее задание - Механизм блокировок (Блокировки)

## Настройка сервера
Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд.

  1) Вношу изменения в файл конфигурации: ``nano /var/lib/postgres/data/postgresql.conf``

     <img src="https://github.com/user-attachments/assets/6cd74c1a-ca12-442d-a1ff-6f0754dfb0fe" alt="drawing" width="500"/>

  2) Перезапускаю кластер: ``sudo systemctl restart postgresql``
  3) Создаю тестовую таблицу ``CREATE TABLE test_locks (value INT);`` и вношу в нее тестовую строку ``INSERT INTO test_locks (value) VALUES (1);``
  4) Воспроизвожу ситуацию, при которой в журнале появятся такие сообщения путем одновременного запуска двух транзакций в разных сессиях изменяющих строку в тестовой таблице: сеанс 1 ``UPDATE test_locks SET value = 2 WHERE id = 1;``, сеанс 2 ``UPDATE test_locks SET value = 3 WHERE id = 1;``
  5) Проверяю лог посгрес ``journalctl -u postgresql`` и вижу там сообщение о блокировке с типом ожидания "ShareLock"

     <img src="https://github.com/user-attachments/assets/47b775e8-368c-444f-b482-38f14fa71675" alt="drawing" width="500"/>
     
## Работа с блокирвками 

Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks.

  1) Первая сессия: ``UPDATE test_locks SET value = 2 WHERE id = 1;``
  2) Вторая сессия: ``UPDATE test_locks SET value = 3 WHERE id = 1;``
  3) Третья сессия: ``UPDATE test_locks SET value = 4 WHERE id = 1;``
  4) Изучаю блокировки в представлении pg_locks: ``SELECT * FROM pg_locks;``

     <img src="https://github.com/user-attachments/assets/87bd535c-b0af-45be-a6d7-4a3241413a0a" alt="drawing" width="500"/>
  
  5) В данном случае мы видим, что блокировки произошли между процессами с pid'ами 2124, 2126 и 2128. Каждая из них пытается запросить эксклюзивную блокировку, для изменения данных в строке при этом процессы 2126 и 2128 заблокированы процессом 2124 который первый получил право на изменение данных в строке, и теперь процесс 2126 ожидает его завершения с типом ожидания "ShareLock", а процесс 2128 все ещё имеет тип ожидания "ExclusiveLock".
  6) Я завершу все эти транзакции.
  7) Тепрерь изучу журнал событий, чтобы выяснить попала ли туда вся эта информация:

     <img src="https://github.com/user-attachments/assets/b2bb8c9c-7445-45f6-8cb0-d0945fea2a55" alt="drawing" width="500"/>

  8) В эих сообщениях мы наблюдаем всю историю по блокировкам, которая описана выше, а также мы видим когда появились первые и последующие блокировки и когда они разрешились. Из этого можно сделать вывод, что разобраться в ситуации постфактум, изучая журнал сообщений вполне возможно!

## Задание со *

Попробуем воспроизвести ситуацию гду две транзакции, выполняют единственную команду UPDATE одной и той же таблицы (без where).

  1) Первая сессия: ``UPDATE test_locks SET value = value + 1;``
  2) Вторая сессия: ``UPDATE test_locks SET value = value + 1;``
  3) Проверяю наличие блокировок в представлении pg_locks:

     <img src="https://github.com/user-attachments/assets/da750f49-530e-4550-a65c-209fb7f414db" alt="drawing" width="500"/>

  4) Видно что в момент, когда обе транзакции начали работать с одной и той же строкой то появилась блокировка, а именно процесс 2126 был заблокирован процессом 2124 
  5) А также это видно и в журнале событий:

     <img src="https://github.com/user-attachments/assets/668e88c3-223f-4b3e-8798-c2ab1e29490b" alt="drawing" width="500"/>

Из этого можно сделать вывод, что блокировка между двумя транзакциями, которые выполняют единственную команду UPDATE одной и той же таблицы (без where) вполне возмоное явление. 

**Готово! И на этом домашнее задание выполнено!**

